3.October_JavaScript  심화 1 _ [값 더 알아보기](https://helloworldjavascript.net/pages/220-value-in-depth.html)

10.October_JavaScript 심화_1 수업시간 설명 추가 


# 값 더 알아보기

## let, const 변수와 블록 스코프

* `let`과 `const`는 같은 이름을 갖는 변수의 재선언을 허용하지 않습니다.

* 변수가 선언되기 전에 참조하려고 하면 에러가 납니다.

* `let`과 `const`가 바로 블록 스코프(block scope)를 갖는다

* 변수를 선언 할 때 const를 애용하시고, 변수에 다른 값을 대입해야 할 일이 생기면 그때 let을 사용하세요


> 함수의 매개변수나, var 변수는 함수 스코프를 갖는다. | 만약 함수가 없으면 var는 전체가 유효 스코프!
> let, const 변수는 블록 스코프를 갖는다.

|		|	const	|	let		|	var 	|
|---------|-------------|-------------|--------------|
|스코프 |블록스코프| 블록스코프| 함수스코프|
|재대입|	 X	 	|		O	|		O	|
|재선언|	X		|		X	|		O	|
|Hosting|	X		|	X		|	O		|
|사용권장 | 1순위 	|	2순위	|	3순위	|


### Hosting : var로 선언된 변수는 내부적으로 함수 혹은 같은 스코프 안에만 있다면 변수가 선언되기 전에도 해당 변수에 접근 가능! _ let과 const에서는 hosting기능이 빠져있어용

## 전역변수 (global variable)

* 전역스코프는 스코프 체인 가장 바깥 쪽에 있는 스코프
* 전역스코프에서 선언된 변수를 전역 변수라고 한다

* 변수를 명시적으로 전역스코프에 선언하지 않더라도 한 번도 선언되지 않은 이름으로 안쪽 스코프에서 let, const, var를 붙여주지 않고 변수를 선언하면, 전역스코프에 변수가 만들어진다.

```js
function func() {
  variable = 1; // `variable`이라는 변수가 선언된 적 없으므로, 전역 변수가 됩니다.
}

func();
console.log(variable); // 1
```

[특징]

+ 코드의 어떤 부분에서든 아무런 제한 없이 접근하고 조작 할 수 있다
+ 전역변수에 의쫀해서 프로그래밍을 하는 것은 굉장히 금기시 되는 일이다

[전역변수를 남용하다보면...]

+ 프로그램의 크기가 커짐에 따라 변수의 값이 어디서 어떻게 변경될지 예측하기 힘들다
+ 프로그램의 너무 많은 부분이 결합(coupling)된다 _ 멀리 떨어져 있는 코드가 결합되는 일은 노노해
+ 코드를 이해하기 힘들 ( 다른 곳에 위치하는 부분에 의존하기 때문에)

[권장되는 방법]

변수를 선언할 때, 그 변수를 필요로 하는 작은 스코프 안에서만 접근 할 수 있도록 해줘랑
만약, 특정 값을 공유하고 그 값을 변경해야 할 일이 생기면 

+ 모듈, 클래스, 의존성 주입, Redux, Moby 등 다른 기법을 사용해자

## 전역객체(global Object)

* 전역변수가 선언되면, 이 변수 또한 전역객체의 속성이 되어 전역객체를 통해서도 접근 가능하다
* 전역객체의 이름은 JavaScript 구동환경마다 다르다

|구동환경|전역객체이름|
|----------|----------------|
|웹브라우저|window|
|웹 워커|self|
|Node.js|global|


* 전역객체에는 구동환경에서 유용하게 쓸 수 있는 함수가 미리 적재되어 있다( 웹브라우저는 fetch 함수 | Node.js는 require 함수)

## 참조 (Reference)

JavaScript에는 모두 7가지 타입이 존재한다

[원시타입 : Primitive type]

* Boolean
* Null
* Undefined
* Number
* String
* Symbol

[참조타입 :  Reference type]

* Object

### 참조(reference)란, 객체가 컴퓨터 메모리 상에서 어디에 저장되었는지를 가리키는 값

### 함수호출 :  함수호출시 객체를 인수로 넘긴다면, 실제로 복사된 것은 객체가 아니라 참조!!

> 원시타입을 넘길때에는 원본을 변경할 수 없지만(값이 복사되어 전달됨), 참조타입을 넘길때에는 원본을 변경할 수 있다(객체가 복사되어 전달됨)!

```js
const obj = {};

function addProp(o) {
  o.prop = 1;
}

// 변수 `obj`에 저장되어 있는 참조가 매개변수 `o`에 복사됩니다.
addProp(obj);

console.log(obj.prop); // 1
```

### 객체의 같음(Equality) 

* === 연산자를 사용해 '객체의 참조' 를 비교한다
* 코드 작성시, 객체에 대한 비교를 하고싶다면...
+ 지금 객체 내용을 비교하고 싶은지 : 등호연산자말고 다른방법을 사용해야한다! _ 깊은 비교
+ 객체의 참조를 비교하려고 하는 것인지를 생각해봐라 : 
* 그런 후, 함수 혹은 메소드를 작성해서 비교에 이용해라

## 불변성(Immutability)

* 원시타입의 값 자체의 내용은 변경할 수 있는 방법은 없다.
* 'JavaScript의 원시 값은 불변 (immutable)이다'

[예를 들면]

+ 문자열을 변형하는 메소드는 모두 기존 문자열의 내용을 바꾸는게 아니라 새 문자열을 반환한다
 
+ 변수에 저장된 원시타입의 값을 바꾸려면, 오직 변수에 다른 값을 대입하는 방법 뿐이다

### 객체는 가변(mutable)적이기 때문에, 프로그래밍이 어려워지기도 한다

[대안]

+ Object.freeze : 객체를 얼려서 속성의 추가/변경/삭제를 막는다

- (다만 Object.freeze를 호출한다고 해서 객체 안에 있는 객체까지 얼려버리지는 않으므로, 중첩된 객체에는 Object.freeze를 사용하기가 조금 까다롭습니다. 그리고, 다음에 소개할 방법과 비교하면 여러모로 편의성이 떨어집니다. 

```js
const obj = {prop: 1};

Object.freeze(obj);

// 모두 무시됩니다.
obj.prop = 2;
obj.newProp = 3;
delete obj.prop;

console.log(obj); // { prop: 1 }
```

+  ([immutable.js](https://facebook.github.io/immutable-js/) 또는 [immer](https://github.com/mweststrate/immer)_같은 라이브러리 사용하는 방법도 있음)

## 래퍼객체(Wrapper Object)

래퍼 객체를 생성시키기 위해 사용되는 생성자들의 목록

* String
* Number
* Boolean
* Symbol

이런 생성자들을 이용해 직접 객체를 생성 할 수도 있지만, 그렇게 하지 않아도 원시 값에 대한 메소드를 호출하거나 속성을 읽을 수가 있어서 직접 객체를 생성하는 일은 잘 없다



# TIL

알게된 점 

+ const, let, var의 차이점
+ 수업시간에 선생님께서 언급하신 함수 스코프 이외에 다른 스코프가 존재함
+ 전역스코프, 전역변수, 전역객체가 어떤식으로 동작원리
+ 컴퓨터는 객체가 메모리상에 어디에 저장되었는지에 따라 같은지 다른지 판단한다(reference:참조)
+  hosting에 대해 물어보는 면접 질문도 있옹 : 변수의 선언부를 맨 위로 끌어올려지는 기능!
좀 더 공부가 필요한 부분

+ Object.freeze /  Immutable.js 동작 방법 : React수업할때 설명해주신다고함!!

