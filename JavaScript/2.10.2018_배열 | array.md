2.Oct.2018 _ JavaScript [배열](https://helloworldjavascript.net/pages/190-array.html) 수업 

# 배열

배열은 JavaScript에 내장되어 있는 자료구조 이다. 배열은 객체의 일종이지만, 내부적으로 특별하게 취급되어 일반적인 객체들과는 다른 특징을 갖고 있다. 

```js
typeof [ ];  // 'object'
```
배열 안에 들어있는 값들을 **요소(element)**혹은 **항목(item)**이라고 한다. "배열 `[1,2,3]`은 세 개의 요소를 갖고 있다." 또는 " 배열 `[1,2,3]`의 두 번째 항목은 `2`이다."와 같이 말할 수 있다. 객체와 배열의 가장 큰 차이점은, 배열의 각 요소 간에는 **순서가 있다**는 점이다.

배열은 `Array` 생성자의 인스턴스 이다. 그러니까, **배열의 프로토타입으로 `Array.prototype`객체가 지정되어 있다** 이 객체에 여러 메소드들이 내장 되어 있는데, 그 [목록](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array#%EB%A9%94%EC%84%9C%EB%93%9C)을 확인해보자

## 배열 생성하기 

### 배열 리터럴

배열은 **배열 리터럴(array literal)**을 통해서 생성하는 것이 가장 쉽다.

> 가장 많이 사용된다

```js
const empty = [ ]; // 빈 배열
const numbers = [1, 2, 3]; // 숫자가 들어있는 배열
const strings = ['one', 'two', 'three']; // 문자열이 들어있는 배열
const objects = [{prop:1}, {prop:2}, {prop:3}]; // 객체가 들어있는 배열
const mixed = [1, 'one', {prop:1}, null ]; // 아무거나(?) 들어있는 배열
```
### Array 생성자

> 자주 쓰지지 않아요 :  일관적이지않아요

**`Array` 생성자**를 통해서도 배열을 생성 할 수 있다. `Array`생성자는 주어지는 인수에 따라 두 가지 서로 다른 방식으로 동작한다. 

1. 수 타입의 인수가 하나 주어질 때는 해당 수 만큼 길이를 갖는 비어있는 배열을 만들어낸다. 만약 인수가 양의 정수가 아니라면 에러를 낸다.

1. 이 외에도 다른 모양으로 인수가 주어지면 그 인수들을 요소로 갖는 배열을 생성한다. 

```js
new Array(1); // [empty]
new Array(1000); // [empty x 1000]

new Array(1, 2, 3); // [1, 2, 3]
```

### Array.of

이렇게 일관적이지 못한 생성자의 동작방식 때문에, ES2015에 `Array.of` 정적 메소드가 추가되었다. 이 메소드는 위의 2번 방식으로만 동작한다. **`Array` 생성자를 사용할 때에는 1번 방식으로만 사용하고, 2번 방식의 코드를 작성할 때는 생성자 대신 `Array.of` 정적 메소드를 사용하자**

> `Array.of( 인수 )` // 항상 인수가 들어있는 배열을 생성해준다

> 자주 쓰이지는 않아요

```js
new Array(1, 2, 3); // 이렇게 하지 마세요!
Array.of(1, 2, 3); // 대신 이렇게 하세요.

// `Array.of` 정적 메소드는 인수가 하나이더라도 그 인수를 요소로 갖는 배열을 반환합니다. 
Array.of(!); // [1]

// 생성자는 이런 용도로만 사용하세요.
new Array(1000); // [empty x 1000] 
```

### Array.from

> 꽤 자주 사용됩니다용

JavaScript에는 **유사 배열 객체(array-like object)**와 **iterable**이라는 개념이 있어서, 이에 해당하는 값들은 `Array.from` 정적 메소드를 통해 배열로 쉽게 변환될 수 있다. 앞의 두 개념에 대해서는 Iterable 챕터에서 자세히!

```js
// `string` 타입은 래퍼 객체를 통해 iterable로 다루어질 수 있다.
Array.from('hello'); // ["h", "e", "l", "l", "o"]
// 'hello'.split(' ')이랑 같은 결과를 낸다!
```
## 요소 읽기

배열의 각 요소는 **인덱스(index)**를 이용해서 읽어올 수 있다. 인덱스는 객체의 속성 이름과 비슷한 역할을 하지만, **0 이상의 정수**만이 배열의 인덱스가 될 수 있다. 

배열을 생성하면, 배열 안에 들어있는 각 요소는 순서대로 0부터 시작하는 인덱스를 갖게 된다. 대문자 표기법에 인덱스를 사용함으로써 원하는 요소를 가져올 수 있다. 

```js
const arr = ['one', 'two', 'three' ];
arr [0]; //  'one'
arr [1]; //  'two'
arr [2]; // 'three'
arr [3]; // undefined
```
위에서 볼 수 있듯이, 인덱스는 0부터 시작한다. 즉, **첫 번째 요소를 가리키는 인덱스는 1이 아니라 0이다.** 

## 요소 수정하기

객체와 마찬가지로 대괄호 표기법을 이용해서 요소를 수정할 수 있다. 

```js
const arr = [false, false, false];
arr[1] = true;
console.log(arr); // [false, true, false]
```

`fill` 메소드를 사용하면 한꺼번에 많은 요소를 같은 값으로 바꿀 수 있다. 

```js
const arr = [1, 2, 3, 4, 5 ];

// 전체를 0으로 채우기
arr.fill(0);
console.log(arr); //[0, 0, 0, 0, 0]

// 인덱스 2와 4 사이를 1로 채우기 | .slice()할 때랑 비슷하게 번호메김
arr.fill (1, 2, 4);
console.log(arr); // [0, 0, 1, 1, 0];
```
`Array`생성자와 `fill`매소드를 사용하면, 큰 배열을 만들고 값을 채워넣는 일을 쉽게 할 수 있다. 

```js
new Array(1000); // [empty x 1000]
new Array(1000).fill(5); // [5, 5, 5, 5, ...]
```

## 배열의 끝 부분에서 요소를 추가/제거하기

`push`메소드와 `pop`메소드를 사용하면 **배열의 끝 부분에서** 요소를 추가하거나 제거할 수 있다. 

* `push()` = 원본배열에 추가하고, 추가된 항목이 몇개인지 반환해줌
* `pop()` = 원본배열에서 지우고, 반환값으로 지운값을 반환하고 반환함!  


```js
const arr = [ ];
arr.push('one'); // 1 (요소가 추가된 후의 배열의 길이를 반환함)
arr.push('two', 'three'); // 3

console.log(arr); // [ 'one', 'two', 'three' ]

// 배열의 요소 삭제하기
arr.pop(); // 'three'
arr.pop(); // 'two'
arr.pop(); // 'one'
arr.pop(); // undefined (더 이상 배열에 요소가 남아있지 않으면 `undefined`를 반환)
```

## 배열의 시작 부분에서 요소를 추가/제거하기

반대로 `unshift`,`shift`메소드를 사용해 **배열의 시작 부분에서** 요소를 추가하거나 제거할 수도 있다. 

```js
const arr = [ ];
arr.unshift(1); // 요소가 추가된 후의 배열의 길이를 반환)
arr.unshift(2,3); // 3

console.log(arr); // [2, 3, 1]

// 배열의 요소 삭제하기
arr.shift(); // 2
arr.shift(); // 3
arr.shift(); // 1
arr.shift(); // undefined (더 이상 배열에 요소가 남아있지 않으면 `undefined`를 반환)
```
## 요소를 배열 중간에 삽입하기 (제거할 수도 있음)

`splice`메소드를 사용하면 배열에 속해있는 연속된 여러 요소, 즉 배열의 일부분을 통째로 바꿀 수 있다. 

>`splice` 메소드는 바꿔치기를 통해 제거된 요소(바꿔치기 당한 것)들을 반환

```js
let arr = [1, 2, 3, 4, 5];

// 인덱스 `1`인 요소부터 `3`개를 바꿔치기 합니다.
// `splice` 메소드는 바꿔치기를 통해 제거된 요소들을 반환합니다. 

arr.splice (1, 3, 'two', 'three', 'four'); // [2, 3, 4]
console.log(arr); // [ 1, 'two', 'three', ' four', 5]
```

`splice`로 반드시 같은 개수의 요소만 바꿔치기할 수 있는 건 아니다. 

```js
let arr = [1, 2, 3,  4, 5];
arr.splice(1, 3, 'three'); // [2, 3, 4]
console.log(arr); // [1, 'three', 5]
```
`splice`의 뒤쪽 인수를 생략하면, 요소를 제거할 뿐 배열에 아무것도 삽입하지 않는다. 

```js
let arr = [1, 2, 3, 4, 5];
arr.splice(1,3); // [2,3,4]
console.log(arr); // [1, 5]
```
이렇게 `splice`메소드를 **배열의 중간 부분에 있는 요소를 제거하는데도 활용할 수 있다.

* 배열 중간에 여러개의 요소를 삽입할 수도 있음

```js
let arr = [1, 2, 3, 4, 5]
arr.splice(2, 0, 'one', 'two', 'three'); // [ ] _ 바꿔치기 되는 부분이 없으니까 비어있는 배열이 출력

console.log(arr); //  [1, 2, 'one', 'two', 'three', 4, 5]
```
 

## 배열 뒤집기

배열 `reverse` 메소드를 호출하면 해당 배열을 거꾸로 뒤집어버린다.

> `reverse` 배열을 바꾸고,  뒤집은 원본 배열 그대로를 반환한다

```js
const arr = [1, 2, 3];

// `reverse` 메소드는 `arr`을 뒤집은 후, `arr`을 그대로 반환
arr.reverse(); // [3, 2, 1]
console.log(arr); // [3, 2, 1]
```

## 배열 정렬하기 

배열 `sort`메소드를 통해 원하는 방식대로 배열을 정렬할 수 있다. 

> 기준을 세울 수 만 있다면 뭐든 정렬할 수 있음

```js
const arr = [3, 1, 4 , 5,  2];

// `sort` 메소드는 `arr`을 비교 함수에 따라 정렬한 뒤, `arr`을 그대로 반환한다. 
arr.sort((x, y) => x - y); // [1, 2, 3, 4, 5]
console.log(arr); // [1, 2, 3, 4, 5]
```
`sort` 메소드의 인수에는 **비교 함수**를 넘겨주어야 합니다. 비교 함수는 인수 두 개를 받아서, 아래의 조건에 따라 잘 정렬되도록 적절한 값을 반환해주어야 합니다.

-

만약 어떤 두 값 `a`, `b`에 대해서 비교 함수 `compare`를 `compare(a, b)`와 같이 호출했을 때:

* 음수를 반환하면, a가 b 앞에 오도록 정렬합니다.
* 0을 반환하면, a와 b를 같은 순서로 간주합니다.
* 양수를 반환하면, b가 a 앞에 오도록 정렬합니다.

-

따라서, 어떤 배열을 정렬할 때에는 **어떤 값을 기준으로 정렬할 지**를 생각해 본 다음, 정렬함수를 만들 때 **오름차순으로 정렬할 지, 내림차순으로 정렬할 지**를 생각해보면 됩니다. 예를 들어, **문자열의 길이를 기준으로 내림차순 정렬**을 하고 싶다면 아래와 같이 하면 됩니다.

```js
const names = ['Denton', 'Kathleen', 'Ebba', 'Bruce'];
names.sort((x, y) => y.length - x.length);
console.log(names); // [ 'Kathleen', 'Denton', 'Bruce', 'Ebba' ]
```
여기서 주의할 점이 하나 있습니다. 비교 함수를 넘기지 않더라도 정렬이 잘 되는 것처럼 보일 수 있습니다.

```js
const arr = [3, 1, 4, 5, 2];
arr.sort(); // [1, 2, 3, 4, 5]
```

하지만 비교 함수를 인수로 넘겨주지 않으면, **`sort` 메소드는 먼저 요소를 전부 문자열로 변환한 후, 유니코드 코드포인트를 비교하는 방식으로 정렬**을 합니다. 따라서 기대했던 것과는 전혀 다른 결과가 나올 수 있으니, `sort` 함수를 사용할 때는 꼭 비교함수를 넘겨주세요.

> 유니코드는 앞에서부터 하나씩 살펴보고 낮은 수부터 앞에 배열한다

```js
[20, 3, 100].sort(); // [100, 20, 3]
['abc', 'DEF', 'aBC'].sort(); // [ 'DEF', 'aBC', 'abc' ]

[20, 3, 100].sort((x, y) => x - y); // [3, 20, 100]
['abc', 'DEF', 'aBC'].sort((x, y) => x.localeCompare(y)); // [ 'abc', 'aBC', 'DEF' ]
```

> string타입 10, 11번 예제에서 한번 나왔음  ' 유니코드 코드포인트 비교!  사전순 비교를 하고 싶을 때 `.localeCompare()`


## 배열의 길이

배열의 길이는 `length` 속성을 통해 쉽게 확인할 수 있습니다. 배열의 길이가 변함에 따라, `length` 속성의 값도 자동으로 달라집니다.

```js
const arr = [];
console.log(arr.length); // 0
arr.push(1, 2, 3);
console.log(arr.length); // 3
```

`length` 속성에 값을 대입해서 배열의 길이를 늘였다 줄였다 하는 것도 가능하지만, **이런 방식이 권장되지는 않습니다.**

```js
const arr = [];

// 배열의 길이 늘이기
arr.length = 10;
console.log(arr); // [empty × 10]  _ 이렇게 늘리는거보다 .push()를 사용하는게 더 바람직함

// 배열의 길이 줄이기 (줄어든 만큼 뒤쪽에 있는 요소들은 버려집니다.)
arr.fill(1);
arr.length = 2;
console.log(arr); // [1, 1] 
```

## 배열 순회하기

배열의 각 요소를 차례대로 돌면서 요소에 대한 작업을 하는 것을 가지고 **순회(traverse)**라고 합니다. 배열을 순회하는 방법에는 여러 가지가 있습니다.

### `for` 구문

일단은 단순하게 `for` 루프를 사용해서 배열의 길이만큼 루프를 돌며, 인덱스를 통해 배열의 요소에 접근해 보겠습니다.

```js
const arr = [1, 2, 3];

for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}
```

위 방식은 전통적으로 많이 쓰이던 방식이었습니다. 하지만, ES5에 `forEach` 메소드가 추가되고, ES2015에 `for...of` 구문이 추가되면서 위 방식은 잘 쓰이지 않게 되었습니다.

`forEach` 메소드

배열의 `forEach` 메소드를 사용하면, 배열의 각 요소에 대해 **함수**를 호출할 수 있습니다.

> 함수를 인수로 받음

```js
const arr = [1, 2, 3];

arr.forEach(item => {
  console.log(`현재 요소 ${item}에 대해 함수가 실행되고 있습니다.`);
});
```

`for` 구문을 사용했을 때와 비교해보면, 읽기에 더 자연스러운 코드가 되었습니다.

`forEach` 메소드에 넘기는 함수에는 총 세 개의 인수가 들어옵니다. 첫 번째로는 현재 순회중인 배열의 **요소**, 두 번째로는 요소의 **인덱스**, 세 번째로는 순회중인 **배열**이 들어옵니다.

```js
const arr = [1, 2, 3];
arr.forEach((item, index, array) => {
  console.log(`현재 ${index + 1}번째 요소에 대해 함수가 실행되고 있습니다.`);
})
```

### `for...of 구문`

> 젤 많이 쓰여용

ES2015에 도입된 `for...of` 구문은, 역시 ES2015에 도입된 **iterable**을 순회하기 위해 사용할 수 있습니다. 배열 역시 **iterable**이므로, `for...of` 구문을 사용해 순회할 수 있습니다. Iterable에 대해서는 Iterable 챕터에서 자세히 다룹니다.

```js
const arr = [1, 2, 3, 4, 5];

for (let item of arr) { 			// for(요소로 쓸 것 변수정의 of 순회를 돌 배열)
  console.log(item);
}
```

많은 기능이 있어요

```js

//블록스코프를 만들고 그것은 for문 안에서만 유효하다

const arr = [1, 2 ,3]

for (const item of arr){
	console.log(item)
};
```

### 어떤 것을 써야 하나요?

단순히 배열을 순회하기 위한 목적이라면 **`for...of` 구문을 사용**하는 것이 코드의 간결성이나 속도 측면에서 유리합니다. 다만, 배열을 순회하면서 배열의 **인덱스가 필요한 경우**에는 `for...of` 구문을 사용할 수 없습니다. 이 때에는 `forEach` 메소드를 사용하면 되고, **코드의 실행 속도가 정말로 중요한 부분**에서는 역사와 전통의 `for` 구문을 사용하면 됩니다.

## 배열로부터 새로운 값 생성

배열을 다루다보면 배열로부터 다른 배열, 혹은 다른 값을 계산해내야 하는 작업을 많이 하게 됩니다. **배열을 순회하는 것만으로도 이런 작업들을 할 수는 있지만**, 배열에 내장된 메소드를 활용하면 **훨씬 더 간결한 코드로 같은 작업**을 할 수 있습니다.

아래 메소드들은 모두 **원본 배열에 아무런 영향을 미치지 않습니다.**

### slice | string에 있는 .slice()메소드와 거의 비슷함

`slice` 메소드는 배열의 일부분에 해당하는 **새로운 배열**을 반환합니다.

```js
const arr = [1, 2, 3, 4, 5];

// 인덱스 2부터 인덱스 4 사이의 요소들을 가지고 새로운 배열을 생성
const newArr = arr.slice(2, 4); // [3, 4]

// newArr을 조작해도, 원본 배열에는 영향을 미치지 않습니다.
newArr[0] = 5;
console.log(newArr); // [5, 4]
console.log(arr); // [1, 2, 3, 4, 5]
```
첫 번째 인수의 기본값은 0, 두 번째 인수의 기본값은 배열의 `length` 속성입니다. 즉, 인수 없이 호출하면 배열 전체가 **복사**됩니다.

```js
const arr2 = arr.slice(); // [1, 2, 3, 4, 5];
// 기본값은 0, 두 번쨰 인수의 기본값은 arr.length이다
```
> const는 값이 재대입이 되지 않는 것이지, 값의 정렬변화에는 상관없쯈


다만, `slice`는 **얕은 복사(shallow copy)**를 하므로, 배열 안에 배열 또는 객체가 들어있을 때는 주의해서 사용해야 합니다. 얕은 복사에 대해서는 객체 더 알아보기 챕터에서 자세히 다룹니다.

### map

`map` 메소드는 배열의 **각 요소에 함수를 적용**해서, 그 반환값을 요소로 갖는 **새로운 배열**을 만듭니다. forEach와 비슷해 보이지만, 새로운 배열을 만든다는 점이 다릅니다.

```js
const arr = [1, 2, 3, 4, 5];

// `arr`의 각 요소를 제곱한 값으로 새 배열을 만듭니다.
const newArr = arr.map(item => item ** 2);
console.log(newArr); // [1, 4, 9, 16, 25]
```

`map` 역시 인수로 들어온 함수를 호출할 때 세 개의 인수를 넘깁니다. 이는 `forEach`와 똑같습니다.

```js
arr.map((item, index, array) => {
  return item * index;
}); // [0, 2, 6, 12, 20]
```

### concat

`concat` 메소드는 여러 배열을 연결해서 새 배열을 만들 때 사용됩니다.

```js
const arr = [1, 2];

arr.concat([3, 4], [5, 6], [7, 8]); // [1, 2, 3, 4, 5, 6, 7, 8]
```

### reduce

`reduce` 메소드는 모든 요소의 값을 **종합**해서 하나의 값으로 만드는 계산을 할 때 사용합니다.

```js
const arr = [1, 2, 3];

arr.reduce((acc, item) => acc + item, 0); // 6
```

위 코드에서 일어난 일을 순서대로 써보면 다음과 같습니다.

1. 초기값 0과 배열의 첫 번째 요소인 1을 인수로 해서 함수를 호출합니다. 즉, acc 매개변수에 0이 대입되고, item 매개변수에 1이 대입됩니다. 결과값은 1이 됩니다. 이 값을 누적값(accumulator)라고 부릅니다.
1. 누적값 1과 배열의 두 번째 요소인 2를 인수로 해서 함수를 호출합니다. 결과값 3이 다시 누적값이 됩니다.
1. 누적값 3과 배열의 세 번째 요소인 3을 인수로 해서 함수를 호출합니다. 결과값은 6입니다.
1. 더 이상 요소가 남아있지 않으므로 reduce 호출의 결과값은 6이 됩니다.

처음에는 어렵지만, 익숙해지면 `reduce`는 **배열에 대한 계산을 하는 만능 도구**로 사용할 수 있습니다. 실제로, 배열의 많은 메소드들이 `reduce`를 통해 다시 구현될 수 있습니다. 이는 연습문제로 남깁니다.

`reduce`에 주어지는 함수 역시 `forEach`나 `map`과 마찬가지로 여러 개의 인수를 받는데, 맨 앞에 누적값이 추가되어 `(누적값, 현재 요소, 인덱스, 배열)`와 같은 인수를 받습니다.

```js
const arr = ['one', 'two', 'three'];

arr.reduce((acc, item, index, array) => {
  return acc + `(${index}: ${item})`;
}, ''); // '(0: one)(1: two)(2: three)'
```

`reduce` 메소드에 초기값 인수를 주지 않으면, 첫 번째 인수가 초기값으로 지정되어 첫 번째 요소와 두 번째 요소에 대한 계산부터 시작합니다. 즉, 위 두 예제에서 초기값을 생략해도 같은 결과가 나옵니다. 다만, 배열의 요소가 하나 밖에 없다면 아래와 같이 계산이 수행되지 않고 첫 번째 요소가 그대로 반환되므로, **초기값은 항상 제공해주는 것이 좋습니다.**

```js
const arr = ['one'];

// 문자열의 길이를 모두 더하려고 했지만...
// 계산을 수행할 대상이 하나밖에 없어서 함수가 호출되지 못하고 결과값으로 'one'이 반환됩니다.
arr.reduce((acc, item) => {
  return acc + item.length;
}); // 'one'

// 초기값을 주면 계산이 제대로 수행됩니다.
arr.reduce((acc, item) => {
  return acc + item.length;
}, 0); // 3
```

마지막으로, 계산을 오른쪽부터 수행하는 `reduceRight` 메소드도 있으니 확인해보세요.

### filter

`filter` 메소드를 통해 배열에서 원하는 요소만을 골라내어 새로운 배열을 생성할 수 있습니다. `filter` 메소드에는 진리값(boolean)을 반환하는 함수를 주어야 합니다. 이처럼 **진리값을 반환하는 함수**를 **predicate**이라고 합니다.

```js
const arr = [1, 2, 3, 4, 5];

// 짝수만 골라내기
arr.filter(item => item % 2 === 0); // [2, 4];
```

`filter`에 주어지는 함수 역시 `forEach`와 마찬가지로 `(현재 요소, 인덱스, 배열)`의 세 인수를 받습니다.

### join

`join` 메소드는 배열의 요소들을 문자열로 변환 후, 메소드에 주어진 구분자(separator)를 이용해 하나의 문자열로 결합하여 반환합니다.

> 배열을 문자열로 바꾸고싶을때

```js
const arr = [1, 2, 3];

arr.join('&'); // '1&2&3'
```

구분자를 넘기지 않으면, `,` 문자가 구분자로 사용됩니다.

```js
const arr = [1, 2, 3];

arr.join(); // '1,2,3'
```

### 요소 찾기

`indexOf`와 `lastIndexOf` 메소드를 사용하면 특정 요소가 배열의 몇 번째에 위치하는 지를 알아낼 수 있습니다. `indexOf`는 배열의 왼쪽부터, lastIndexOf는 오른쪽부터 검색해서 처음 만나는 요소의 인덱스를 반환합니다. 만약 일치하는 요소가 없다면, 두 메소드 모두 `-1`을 반환합니다.

```js
const arr = ['a', 'b', 'c', 'b', 'a'];

arr.indexOf('b'); // 1
arr.lastIndexOf('b'); // 3

arr.indexOf('z'); // -1 					*찾는 값이 없으면 -1 반환*
arr.lastIndexOf('z'); // -1
```

두 메소드 모두 두 번째 인수로 **시작 인덱스**를 받습니다. 시작 인덱스가 주어지면 해당 인덱스부터 검사를 시작합니다.

```js
const arr = ['a', 'b', 'c', 'b', 'a'];

arr.indexOf('b', 2); // 3
arr.lastIndexOf('b', 2); // 1
```

`find` 메소드와 `findIndex` 메소드를 사용하면 특정 조건을 만족하는 요소를 찾을 수 있습니다. 두 메소드 모두 predicate을 이용해 왼쪽부터 검사해서 처음 만나는 요소를 찾습니다. `find`는 요소 자체를 반환하며, `findIndex`는 요소의 인덱스를 반환한다는 차이점이 있습니다. 조건을 만족하는 요소를 찾지 못하면, `find`는 `undefined`를, `findIndex`는 `-1`을 반환합니다.

> 내가 찾고자 하는걸(뭔지는 모르지만) 지정해준 조건에 맞게 정확히 딱 찾는다!

```js
const names = ['Denton', 'Kathleen', 'Ebba', 'Bruce'];

names.find(item => item.length < 6); // 'Ebba'
names.findIndex(item => item.length < 6); // 2

names.find(item => item.length > 8); // undefined
names.findIndex(item => item.length > 8); // -1
```

`forEach`와 마찬가지로, `find`와 `findIndex`에 주어지는 predicate에는 `(현재 요소, 인덱스, 배열)`의 세 인수가 넘겨집니다.

### 배열이 특정 조건을 만족하는지 판별하기

배열의 세 메소드 `includes`, `every`, `some`는 모두 배열이 특정 조건을 만족하는지를 나타내는 진리값을 반환합니다.

>문자열의 .includes()메소드와 비슷함

ES2016에서 도입된 `includes` 메소드는 배열이 특정 요소를 포함하고 있는지를 판별합니다. `indexOf`로도 비슷한 일을 할 수 있지만 `includes`가 진리값을 반환한다는 점에서 조금 더 편합니다. `includes` 메소드 역시 시작 인덱스를 인수로 받습니다.

```js
const arr = ['one', 'two', 'three'];

arr.includes('one'); // true
arr.includes('one', 1); // false
```

`every`는 predicate을 인수로 받아서, **모든 요소가 조건을 만족하는 지를 검사합니다.**

```js
const arr = ['one', 'two', 'three'];

arr.every(item => item.length > 2); // true
arr.every(item => item.length > 3); // false
```

`some`은 predicate을 인수로 받아서, **조건을 만족하는 요소가 하나라도 있는지 검사합니다.**

```js
const arr = ['one', 'two', 'three'];

arr.some(item => item.length > 3); // true
arr.some(item => item.length > 5); // false
```

`forEach`와 마찬가지로, `every`와 `some`에 주어지는 predicate에는 `(현재 요소, 인덱스, 배열)`의 세 인수가 넘겨집니다.

## 배열인지 아닌지 판별하기

어떤 값이 배열인지 아닌지 판별하기 위해서 `Array.isArray` 정적 메소드를 사용할 수 있습니다.

```js
Array.isArray([]); // true
Array.isArray({}); // false
Array.isArray('hello'); // false
```

## 문자열과 배열

문자열은 배열과 유사한 문법을 통해 다뤄질 수 있습니다. 그리고 문자열의 메소드 중에는 배열의 메소드 중 몇몇과 이름이 같고 완전히 같은 방식으로 동작하는 것들이 있습니다. 문자열 메소드 목록을 확인해보세요.

```js
'hello'[0]; // 'h'
'hello'.slice(2, 4); // 'll'
for (let c of 'hello') {
  console.log(c);
}
```

## 다차원 배열 (Multidimensional Array)

> 바둑게임같은거 만들 때 쓴다용

컴퓨터를 사용하다보면 표 형태의 자료를 많이 다루게 됩니다. JavaScript에서는 표 형태의 자료를 간단히 나타내기 위해 **배열을 요소로 갖는 배열**을 사용할 수 있습니다.

```js
const table = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];
```

이렇게 배열 속에 배열이 중첩되어 있는 자료구조를 가지고 다차원 배열(multidimensional array)라고 합니다.

다차원 배열 속에 있는 요소를 다루기 위해서, 대문자 표기법을 연이어 사용할 수 있습니다.


```js
table[0][1]; // 2
table[2][0]; // 7
```



# 자네 오늘 배운게 뭔가🤓

* 배열을 생성하는데 여러가지 방법이 있다
* .fill()메소드를 사용해서 요소를 수정할 수 있다
* 배열 끝 부분에서 요소를 추가/제거 하는 메소드가 있다
	- .push()
	- .pop()
* 배열 앞 부분에서 요소를 추가/제거 하는 메소드가 있다
	- .unshift()
	- .shift()
* 요소를 배열 중간에 삽입할 수있는 메소드가 있다
	- .splice()
* 배열을 뒤집을 수 있는 메소드가 있다
	- .reverse()
* 배열을 정렬할 수 있는 메소드가 있다
	- .sort()
* .length()메소드를 이용해 배열이 길이를 알 수 있다

* for구문 / .forEach()메소드 / for...of 구문 을 이용해서 배열에 있는 요소들을 순회할 수 있다


* .slice(), .map(), .concat(), .reduce() .filter()는 원본 배열엔 영향 노노
* .slice() 메소드를 이용해 배열로 부터 새로운 값을 생성해 낼 수 있다
* .map() 메소드는 각 요소에 함수를 적용해서, 그 반호나값을 요소로 갖는 새로운 배열을 만들어준다

그 밖에도 여러가지 메소드들이 있다

# 느낀점 2.Oct.2018

너무나 많은 메소드들이 존재한다🤭 일단은 어떤 메소드들이 있는지 알아두고 내가 코드를 짤 때 어떤 것들을 사용할 수 있는지 생각해보고 많이 써보자. 그 방법이 얘네들에게 익숙해 질 수 있는 방법인 것 같다. 처음부터 다 외우려했다가 다른거 놓칠 것 같으니 개념정리라도 열심히 잘하자. 오늘 처음으로 알고리즘 문제 푸는데 어떤 방식으로 접근해야하는지 알 것 같더라. [오늘 푼 것 정리](https://github.com/victoryjkkim92/TIL/blob/master/JavaScript/2-String.md) 8번 부터 14번까지 품. 룰루 신난다. 그럼 이 기세를 몰아서 배열 알고리즘 문제도 풀어봐야징😻
	
























